<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pico Libraries: pico_sat.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pico Libraries
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pico_sat.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Separating Axis Theorem (SAT) Tests written in C99.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="pico__math_8h_source.html">pico_math.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pico_sat.h:</div>
<div class="dyncontent">
<div class="center"><img src="pico__sat_8h__incl.png" border="0" usemap="#apico__sat_8h" alt=""/></div>
<map name="apico__sat_8h" id="apico__sat_8h">
<area shape="rect" title="Separating Axis Theorem (SAT) Tests written in C99." alt="" coords="131,5,219,32"/>
<area shape="rect" href="pico__math_8h.html" title="A 2D math library for games." alt="" coords="124,80,227,107"/>
<area shape="rect" title=" " alt="" coords="5,155,68,181"/>
<area shape="rect" title=" " alt="" coords="92,155,160,181"/>
<area shape="rect" title=" " alt="" coords="185,155,267,181"/>
<area shape="rect" title=" " alt="" coords="292,155,363,181"/>
</map>
</div>
</div>
<p><a href="pico__sat_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsat__circle__t.html">sat_circle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circle shape.  <a href="structsat__circle__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsat__poly__t.html">sat_poly_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polygon shape Must use CCW (counter-clockwise) winding.  <a href="structsat__poly__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsat__manifold__t.html">sat_manifold_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collision manifold Provides information about a collision. Normals always point from shape 1 to shape 2.  <a href="structsat__manifold__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a03cab665057973485e1aef9cd547da8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#a03cab665057973485e1aef9cd547da8f">PICO_SAT_MAX_POLY_VERTS</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a03cab665057973485e1aef9cd547da8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a99ea0002433bfc25ed7e8df67bf3016e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsat__circle__t.html">sat_circle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#a99ea0002433bfc25ed7e8df67bf3016e">sat_make_circle</a> (<a class="el" href="structpm__v2.html">pm_v2</a> pos, <a class="el" href="pico__math_8h.html#aae7836efe3af8fecd46c88a7bf152cba">pm_float</a> radius)</td></tr>
<tr class="memdesc:a99ea0002433bfc25ed7e8df67bf3016e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a circle.  <a href="pico__sat_8h.html#a99ea0002433bfc25ed7e8df67bf3016e">More...</a><br /></td></tr>
<tr class="separator:a99ea0002433bfc25ed7e8df67bf3016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84c5a6525f1a08b7048e3a5946e183a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsat__poly__t.html">sat_poly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#ac84c5a6525f1a08b7048e3a5946e183a">sat_make_poly</a> (const <a class="el" href="structpm__v2.html">pm_v2</a> vertices[], int vertex_count)</td></tr>
<tr class="memdesc:ac84c5a6525f1a08b7048e3a5946e183a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a polygon.  <a href="pico__sat_8h.html#ac84c5a6525f1a08b7048e3a5946e183a">More...</a><br /></td></tr>
<tr class="separator:ac84c5a6525f1a08b7048e3a5946e183a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18941a373b0dd964d23e94aae0b7392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsat__poly__t.html">sat_poly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#ad18941a373b0dd964d23e94aae0b7392">sat_aabb_to_poly</a> (const <a class="el" href="structpm__b2.html">pm_b2</a> *aabb)</td></tr>
<tr class="memdesc:ad18941a373b0dd964d23e94aae0b7392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts and axis-aligned bounding box (AABB) to a polygon.  <a href="pico__sat_8h.html#ad18941a373b0dd964d23e94aae0b7392">More...</a><br /></td></tr>
<tr class="separator:ad18941a373b0dd964d23e94aae0b7392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa95c09f1e0b2a4ffa0538d34a755e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#a0fa95c09f1e0b2a4ffa0538d34a755e5">sat_test_poly_poly</a> (const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *poly_a, const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *poly_b, <a class="el" href="structsat__manifold__t.html">sat_manifold_t</a> *manifold)</td></tr>
<tr class="memdesc:a0fa95c09f1e0b2a4ffa0538d34a755e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if one polygon overlaps with another.  <a href="pico__sat_8h.html#a0fa95c09f1e0b2a4ffa0538d34a755e5">More...</a><br /></td></tr>
<tr class="separator:a0fa95c09f1e0b2a4ffa0538d34a755e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a8f113d52fc898522a29ff3d8f62d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#a67a8f113d52fc898522a29ff3d8f62d3">sat_test_poly_circle</a> (const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *poly, const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *circle, <a class="el" href="structsat__manifold__t.html">sat_manifold_t</a> *manifold)</td></tr>
<tr class="memdesc:a67a8f113d52fc898522a29ff3d8f62d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if a polygon overlaps a circle.  <a href="pico__sat_8h.html#a67a8f113d52fc898522a29ff3d8f62d3">More...</a><br /></td></tr>
<tr class="separator:a67a8f113d52fc898522a29ff3d8f62d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc197160c05b06bff116e9b203c06b55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#afc197160c05b06bff116e9b203c06b55">sat_test_circle_poly</a> (const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *circle, const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *poly, <a class="el" href="structsat__manifold__t.html">sat_manifold_t</a> *manifold)</td></tr>
<tr class="memdesc:afc197160c05b06bff116e9b203c06b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if a circle overlaps a polygon.  <a href="pico__sat_8h.html#afc197160c05b06bff116e9b203c06b55">More...</a><br /></td></tr>
<tr class="separator:afc197160c05b06bff116e9b203c06b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c61580ae793ea4a55562edf74b2fe4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#a8c61580ae793ea4a55562edf74b2fe4e">sat_test_circle_circle</a> (const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *circle_a, const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *circle_b, <a class="el" href="structsat__manifold__t.html">sat_manifold_t</a> *manifold)</td></tr>
<tr class="memdesc:a8c61580ae793ea4a55562edf74b2fe4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if two circles overlap.  <a href="pico__sat_8h.html#a8c61580ae793ea4a55562edf74b2fe4e">More...</a><br /></td></tr>
<tr class="separator:a8c61580ae793ea4a55562edf74b2fe4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ab7467fa5b76c23ab92050e8b1e06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsat__poly__t.html">sat_poly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#a64ab7467fa5b76c23ab92050e8b1e06f">sat_transform_poly</a> (const <a class="el" href="structpm__t2.html">pm_t2</a> *transform, const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *poly)</td></tr>
<tr class="memdesc:a64ab7467fa5b76c23ab92050e8b1e06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a polygon using an affine transform.  <a href="pico__sat_8h.html#a64ab7467fa5b76c23ab92050e8b1e06f">More...</a><br /></td></tr>
<tr class="separator:a64ab7467fa5b76c23ab92050e8b1e06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c37b41b9f2d539c895fd7b8cec5b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsat__circle__t.html">sat_circle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#a15c37b41b9f2d539c895fd7b8cec5b2c">sat_transform_circle</a> (const <a class="el" href="structpm__t2.html">pm_t2</a> *transform, const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *circle)</td></tr>
<tr class="memdesc:a15c37b41b9f2d539c895fd7b8cec5b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a circle using an affine transform.  <a href="pico__sat_8h.html#a15c37b41b9f2d539c895fd7b8cec5b2c">More...</a><br /></td></tr>
<tr class="separator:a15c37b41b9f2d539c895fd7b8cec5b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f408d58d54bbe6ca2d753127621fec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpm__b2.html">pm_b2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#a8f408d58d54bbe6ca2d753127621fec9">sat_poly_to_aabb</a> (const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *poly)</td></tr>
<tr class="memdesc:a8f408d58d54bbe6ca2d753127621fec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounding box for the given polygon.  <a href="pico__sat_8h.html#a8f408d58d54bbe6ca2d753127621fec9">More...</a><br /></td></tr>
<tr class="separator:a8f408d58d54bbe6ca2d753127621fec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dee6d60874abff0635bc8146848d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpm__b2.html">pm_b2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__sat_8h.html#aa1dee6d60874abff0635bc8146848d71">sat_circle_to_aabb</a> (const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *circle)</td></tr>
<tr class="memdesc:aa1dee6d60874abff0635bc8146848d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounding box for the given circle.  <a href="pico__sat_8h.html#aa1dee6d60874abff0635bc8146848d71">More...</a><br /></td></tr>
<tr class="separator:aa1dee6d60874abff0635bc8146848d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Separating Axis Theorem (SAT) Tests written in C99. </p>
<hr  />
 <h2><a class="anchor" id="autotoc_md46"></a>
Licensing information at end of header</h2>
<h2><a class="anchor" id="autotoc_md47"></a>
Features:</h2>
<ul>
<li>Written in C99</li>
<li>Single header library for easy build system integration</li>
<li>Tests overlaps for AABBs, polygons, and circles using SAT</li>
<li>Provides collision information including the normal and amount of overlap</li>
<li>Permissive license (MIT)</li>
</ul>
<h2><a class="anchor" id="autotoc_md48"></a>
Summary:</h2>
<p>The Separating Axis Theorem (SAT) roughly states that two convex shapes do not intersect if there is an axis separating them. In the case of simple shapes the theorem provides necessary and sufficient conditions. For example, in the case of convex polygons, it is sufficient to test the axises along the edge normals of both polygons.</p>
<p>SAT tests are reasonably efficient and are frequently used for static, narrow phase, collision detection in games.</p>
<p>This library provides SAT tests for polygons, AABBs (which are, of course, polygons), and circles. Manifold objects can be passed to test functions so that, in the case of a collision, they will contain the colliding edge normal, overlap (minimum translational distance or MTD), and a vector (minimum translation vector or MTV).</p>
<p>IMPORTANT: Polygons in this library use counter-clockwise (CCW) winding. See the <code>sat_aabb_to_poly</code> for an example.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Usage:</h2>
<p>To use this library in your project, add the following</p>
<blockquote class="doxtable">
<p>#define PICO_SAT_IMPLEMENTATION #include "pico_sat.h" </p>
</blockquote>
<p>to a source file (once), then simply include the header normally.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Dependencies:</h2>
<p>This library depends on "pico_math.h", which must be in the include path. You must also add</p>
<blockquote class="doxtable">
<p>#define PICO_MATH_IMPLEMENTATION #include "pico_math.h" </p>
</blockquote>
<p>to the same or other source file (once). </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a03cab665057973485e1aef9cd547da8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cab665057973485e1aef9cd547da8f">&#9670;&nbsp;</a></span>PICO_SAT_MAX_POLY_VERTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICO_SAT_MAX_POLY_VERTS&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a99ea0002433bfc25ed7e8df67bf3016e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ea0002433bfc25ed7e8df67bf3016e">&#9670;&nbsp;</a></span>sat_make_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsat__circle__t.html">sat_circle_t</a> sat_make_circle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpm__v2.html">pm_v2</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pico__math_8h.html#aae7836efe3af8fecd46c88a7bf152cba">pm_float</a>&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Circle center </td></tr>
    <tr><td class="paramname">radius</td><td>Circle radius </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac84c5a6525f1a08b7048e3a5946e183a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84c5a6525f1a08b7048e3a5946e183a">&#9670;&nbsp;</a></span>sat_make_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsat__poly__t.html">sat_poly_t</a> sat_make_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpm__v2.html">pm_v2</a>&#160;</td>
          <td class="paramname"><em>vertices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_count</td><td>The number of vertices of the polygon </td></tr>
    <tr><td class="paramname">vertices</td><td>The vertices of the polygon (must use CCW winding) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The polygon with the given vertices </dd></dl>

</div>
</div>
<a id="ad18941a373b0dd964d23e94aae0b7392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18941a373b0dd964d23e94aae0b7392">&#9670;&nbsp;</a></span>sat_aabb_to_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsat__poly__t.html">sat_poly_t</a> sat_aabb_to_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpm__b2.html">pm_b2</a> *&#160;</td>
          <td class="paramname"><em>aabb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts and axis-aligned bounding box (AABB) to a polygon. </p>
<p>aabb The AABB </p><dl class="section return"><dt>Returns</dt><dd>the AABB as a polygon </dd></dl>

</div>
</div>
<a id="a0fa95c09f1e0b2a4ffa0538d34a755e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa95c09f1e0b2a4ffa0538d34a755e5">&#9670;&nbsp;</a></span>sat_test_poly_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sat_test_poly_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsat__manifold__t.html">sat_manifold_t</a> *&#160;</td>
          <td class="paramname"><em>manifold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests to see if one polygon overlaps with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly_a</td><td>The colliding polygon </td></tr>
    <tr><td class="paramname">poly_b</td><td>The target polygon </td></tr>
    <tr><td class="paramname">manifold</td><td>The collision manifold to populate (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygons overlap and false otherwise </dd></dl>

</div>
</div>
<a id="a67a8f113d52fc898522a29ff3d8f62d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a8f113d52fc898522a29ff3d8f62d3">&#9670;&nbsp;</a></span>sat_test_poly_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sat_test_poly_circle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsat__manifold__t.html">sat_manifold_t</a> *&#160;</td>
          <td class="paramname"><em>manifold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests to see if a polygon overlaps a circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The colliding polygon </td></tr>
    <tr><td class="paramname">circle</td><td>The target circle </td></tr>
    <tr><td class="paramname">manifold</td><td>The collision manifold to populate (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon and circle overlap, and false otherwise </dd></dl>

</div>
</div>
<a id="afc197160c05b06bff116e9b203c06b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc197160c05b06bff116e9b203c06b55">&#9670;&nbsp;</a></span>sat_test_circle_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sat_test_circle_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsat__manifold__t.html">sat_manifold_t</a> *&#160;</td>
          <td class="paramname"><em>manifold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests to see if a circle overlaps a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circle</td><td>The colliding circle </td></tr>
    <tr><td class="paramname">poly</td><td>The target polygon </td></tr>
    <tr><td class="paramname">manifold</td><td>The collision manifold to populate (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the circle overlaps the polygon, and false otherwise </dd></dl>

</div>
</div>
<a id="a8c61580ae793ea4a55562edf74b2fe4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c61580ae793ea4a55562edf74b2fe4e">&#9670;&nbsp;</a></span>sat_test_circle_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sat_test_circle_circle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsat__manifold__t.html">sat_manifold_t</a> *&#160;</td>
          <td class="paramname"><em>manifold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests to see if two circles overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circle_a</td><td>The colliding circle </td></tr>
    <tr><td class="paramname">circle_b</td><td>The target circle </td></tr>
    <tr><td class="paramname">manifold</td><td>The collision manifold to populate (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the circle and the other circle, and false otherwise </dd></dl>

</div>
</div>
<a id="a64ab7467fa5b76c23ab92050e8b1e06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ab7467fa5b76c23ab92050e8b1e06f">&#9670;&nbsp;</a></span>sat_transform_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsat__poly__t.html">sat_poly_t</a> sat_transform_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpm__t2.html">pm_t2</a> *&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a polygon using an affine transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new polygon </dd></dl>

</div>
</div>
<a id="a15c37b41b9f2d539c895fd7b8cec5b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c37b41b9f2d539c895fd7b8cec5b2c">&#9670;&nbsp;</a></span>sat_transform_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsat__circle__t.html">sat_circle_t</a> sat_transform_circle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpm__t2.html">pm_t2</a> *&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a circle using an affine transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform </td></tr>
    <tr><td class="paramname">poly</td><td>The circle to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new circle </dd></dl>

</div>
</div>
<a id="a8f408d58d54bbe6ca2d753127621fec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f408d58d54bbe6ca2d753127621fec9">&#9670;&nbsp;</a></span>sat_poly_to_aabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpm__b2.html">pm_b2</a> sat_poly_to_aabb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsat__poly__t.html">sat_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounding box for the given polygon. </p>

</div>
</div>
<a id="aa1dee6d60874abff0635bc8146848d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dee6d60874abff0635bc8146848d71">&#9670;&nbsp;</a></span>sat_circle_to_aabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpm__b2.html">pm_b2</a> sat_circle_to_aabb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsat__circle__t.html">sat_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounding box for the given circle. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
