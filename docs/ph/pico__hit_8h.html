<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pico Headers: pico_hit.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Pico Headers
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pico_hit.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Separating Axis Theorem (SAT) Tests written in C99.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="pico__math_8h_source.html">pico_math.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pico_hit.h:</div>
<div class="dyncontent">
<div class="center"><img src="pico__hit_8h__incl.png" border="0" usemap="#apico__hit_8h" alt=""/></div>
<map name="apico__hit_8h" id="apico__hit_8h">
<area shape="rect" title=" " alt="" coords="133,5,218,31"/>
<area shape="rect" href="pico__math_8h.html" title="A 2D math library for games." alt="" coords="124,79,227,104"/>
<area shape="poly" title=" " alt="" coords="178,31,178,65,173,65,173,31"/>
<area shape="rect" title=" " alt="" coords="5,152,68,177"/>
<area shape="poly" title=" " alt="" coords="154,106,73,148,70,143,152,102"/>
<area shape="rect" title=" " alt="" coords="92,152,160,177"/>
<area shape="poly" title=" " alt="" coords="169,106,144,142,140,139,165,103"/>
<area shape="rect" title=" " alt="" coords="185,152,267,177"/>
<area shape="poly" title=" " alt="" coords="186,103,212,139,208,142,182,106"/>
<area shape="rect" title=" " alt="" coords="292,152,363,177"/>
<area shape="poly" title=" " alt="" coords="201,102,291,144,289,149,199,106"/>
</map>
</div>
</div>
<p><a href="pico__hit_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structph__circle__t.html">ph_circle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circle shape.  <a href="structph__circle__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structph__poly__t.html">ph_poly_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polygon shape Must use CCW (counter-clockwise) winding.  <a href="structph__poly__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structph__ray__t.html">ph_ray_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ray (directed line segment)  <a href="structph__ray__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structph__manifold__t.html">ph_manifold_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collision manifold Provides information about a collision. Normals always point from shape 1 to shape 2.  <a href="structph__manifold__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structph__raycast__t.html">ph_raycast_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raycast information.  <a href="structph__raycast__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a46867f0870ad57fe9c2c0ae48e42428b" id="r_a46867f0870ad57fe9c2c0ae48e42428b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a46867f0870ad57fe9c2c0ae48e42428b">PICO_HIT_MAX_POLY_VERTS</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a46867f0870ad57fe9c2c0ae48e42428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adba91cbb255f36b2a3fb0109f299cca4" id="r_adba91cbb255f36b2a3fb0109f299cca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structph__circle__t.html">ph_circle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#adba91cbb255f36b2a3fb0109f299cca4">ph_make_circle</a> (<a class="el" href="structpv2.html">pv2</a> pos, <a class="el" href="pico__math_8h.html#a5ce19b909a88aefe3e3a3beac779f98c">pfloat</a> radius)</td></tr>
<tr class="memdesc:adba91cbb255f36b2a3fb0109f299cca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a circle.  <br /></td></tr>
<tr class="separator:adba91cbb255f36b2a3fb0109f299cca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7955222df8d81bce86ccbec7902047" id="r_a4d7955222df8d81bce86ccbec7902047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structph__poly__t.html">ph_poly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a4d7955222df8d81bce86ccbec7902047">ph_make_poly</a> (const <a class="el" href="structpv2.html">pv2</a> vertices[], int vertex_count)</td></tr>
<tr class="memdesc:a4d7955222df8d81bce86ccbec7902047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a polygon.  <br /></td></tr>
<tr class="separator:a4d7955222df8d81bce86ccbec7902047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138aae4d2dc47b11a23e0e64dea6e2f0" id="r_a138aae4d2dc47b11a23e0e64dea6e2f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structph__ray__t.html">ph_ray_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a138aae4d2dc47b11a23e0e64dea6e2f0">ph_make_ray</a> (<a class="el" href="structpv2.html">pv2</a> pos, <a class="el" href="structpv2.html">pv2</a> dir, <a class="el" href="pico__math_8h.html#a5ce19b909a88aefe3e3a3beac779f98c">pfloat</a> dist)</td></tr>
<tr class="memdesc:a138aae4d2dc47b11a23e0e64dea6e2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a ray.  <br /></td></tr>
<tr class="separator:a138aae4d2dc47b11a23e0e64dea6e2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840c8e99fc78fe7723587566b70e8ec5" id="r_a840c8e99fc78fe7723587566b70e8ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structph__poly__t.html">ph_poly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a840c8e99fc78fe7723587566b70e8ec5">ph_aabb_to_poly</a> (const <a class="el" href="structpb2.html">pb2</a> *aabb)</td></tr>
<tr class="memdesc:a840c8e99fc78fe7723587566b70e8ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts and axis-aligned bounding box (AABB) to a polygon.  <br /></td></tr>
<tr class="separator:a840c8e99fc78fe7723587566b70e8ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391ac270ec1bcf4a1040b5efa117581f" id="r_a391ac270ec1bcf4a1040b5efa117581f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a391ac270ec1bcf4a1040b5efa117581f">ph_sat_poly_poly</a> (const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *poly_a, const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *poly_b, <a class="el" href="structph__manifold__t.html">ph_manifold_t</a> *manifold)</td></tr>
<tr class="memdesc:a391ac270ec1bcf4a1040b5efa117581f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if one polygon overlaps with another.  <br /></td></tr>
<tr class="separator:a391ac270ec1bcf4a1040b5efa117581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c37f7de9b8744012085830dbd10942" id="r_ac3c37f7de9b8744012085830dbd10942"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#ac3c37f7de9b8744012085830dbd10942">ph_sat_poly_circle</a> (const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *poly, const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *circle, <a class="el" href="structph__manifold__t.html">ph_manifold_t</a> *manifold)</td></tr>
<tr class="memdesc:ac3c37f7de9b8744012085830dbd10942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if a polygon overlaps a circle.  <br /></td></tr>
<tr class="separator:ac3c37f7de9b8744012085830dbd10942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7ad518b177cb49a6a7771e4dd2317c" id="r_acd7ad518b177cb49a6a7771e4dd2317c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#acd7ad518b177cb49a6a7771e4dd2317c">ph_sat_circle_poly</a> (const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *circle, const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *poly, <a class="el" href="structph__manifold__t.html">ph_manifold_t</a> *manifold)</td></tr>
<tr class="memdesc:acd7ad518b177cb49a6a7771e4dd2317c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if a circle overlaps a polygon.  <br /></td></tr>
<tr class="separator:acd7ad518b177cb49a6a7771e4dd2317c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade0516489f38a2b5dda23d26e976bc8" id="r_aade0516489f38a2b5dda23d26e976bc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#aade0516489f38a2b5dda23d26e976bc8">ph_sat_circle_circle</a> (const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *circle_a, const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *circle_b, <a class="el" href="structph__manifold__t.html">ph_manifold_t</a> *manifold)</td></tr>
<tr class="memdesc:aade0516489f38a2b5dda23d26e976bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if two circles overlap.  <br /></td></tr>
<tr class="separator:aade0516489f38a2b5dda23d26e976bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98102c714c9d66eae29fd2ae7b7467c0" id="r_a98102c714c9d66eae29fd2ae7b7467c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a98102c714c9d66eae29fd2ae7b7467c0">ph_ray_line</a> (const <a class="el" href="structph__ray__t.html">ph_ray_t</a> *ray, <a class="el" href="structpv2.html">pv2</a> s1, <a class="el" href="structpv2.html">pv2</a> s2, <a class="el" href="structph__raycast__t.html">ph_raycast_t</a> *raycast)</td></tr>
<tr class="memdesc:a98102c714c9d66eae29fd2ae7b7467c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if ray intersects a (directed) line segment.  <br /></td></tr>
<tr class="separator:a98102c714c9d66eae29fd2ae7b7467c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf724b6bd2a2ec0bbd2e856891a677d8" id="r_adf724b6bd2a2ec0bbd2e856891a677d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#adf724b6bd2a2ec0bbd2e856891a677d8">ph_ray_poly</a> (const <a class="el" href="structph__ray__t.html">ph_ray_t</a> *ray, const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *poly, <a class="el" href="structph__raycast__t.html">ph_raycast_t</a> *raycast)</td></tr>
<tr class="memdesc:adf724b6bd2a2ec0bbd2e856891a677d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if ray intersects a polygon.  <br /></td></tr>
<tr class="separator:adf724b6bd2a2ec0bbd2e856891a677d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad5a532706b71964df83f760ba5e9a3" id="r_a6ad5a532706b71964df83f760ba5e9a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a6ad5a532706b71964df83f760ba5e9a3">ph_ray_circle</a> (const <a class="el" href="structph__ray__t.html">ph_ray_t</a> *ray, const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *circle, <a class="el" href="structph__raycast__t.html">ph_raycast_t</a> *raycast)</td></tr>
<tr class="memdesc:a6ad5a532706b71964df83f760ba5e9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if ray intersects a circle.  <br /></td></tr>
<tr class="separator:a6ad5a532706b71964df83f760ba5e9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea25a1a059e25326b1cd55bde287ca1e" id="r_aea25a1a059e25326b1cd55bde287ca1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpv2.html">pv2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#aea25a1a059e25326b1cd55bde287ca1e">ph_ray_at</a> (const <a class="el" href="structph__ray__t.html">ph_ray_t</a> *ray, <a class="el" href="pico__math_8h.html#a5ce19b909a88aefe3e3a3beac779f98c">pfloat</a> dist)</td></tr>
<tr class="memdesc:aea25a1a059e25326b1cd55bde287ca1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the point along the ray at the specified distance from the origin.  <br /></td></tr>
<tr class="separator:aea25a1a059e25326b1cd55bde287ca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094c30e037fa667889996c4c1e5b33ca" id="r_a094c30e037fa667889996c4c1e5b33ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structph__poly__t.html">ph_poly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a094c30e037fa667889996c4c1e5b33ca">ph_transform_poly</a> (const <a class="el" href="structpt2.html">pt2</a> *transform, const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *poly)</td></tr>
<tr class="memdesc:a094c30e037fa667889996c4c1e5b33ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a polygon using an affine transform.  <br /></td></tr>
<tr class="separator:a094c30e037fa667889996c4c1e5b33ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208e8092fcc819c636dbc776361891e5" id="r_a208e8092fcc819c636dbc776361891e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structph__circle__t.html">ph_circle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a208e8092fcc819c636dbc776361891e5">ph_transform_circle</a> (const <a class="el" href="structpt2.html">pt2</a> *transform, const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *circle)</td></tr>
<tr class="memdesc:a208e8092fcc819c636dbc776361891e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a circle using an affine transform.  <br /></td></tr>
<tr class="separator:a208e8092fcc819c636dbc776361891e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180767bdb437174dc9d3bc23ac67005e" id="r_a180767bdb437174dc9d3bc23ac67005e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpb2.html">pb2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a180767bdb437174dc9d3bc23ac67005e">ph_poly_to_aabb</a> (const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *poly)</td></tr>
<tr class="memdesc:a180767bdb437174dc9d3bc23ac67005e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounding box for the given polygon.  <br /></td></tr>
<tr class="separator:a180767bdb437174dc9d3bc23ac67005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9586763e04eccc001fa17f80d0f1c685" id="r_a9586763e04eccc001fa17f80d0f1c685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpb2.html">pb2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pico__hit_8h.html#a9586763e04eccc001fa17f80d0f1c685">ph_circle_to_aabb</a> (const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *circle)</td></tr>
<tr class="memdesc:a9586763e04eccc001fa17f80d0f1c685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounding box for the given circle.  <br /></td></tr>
<tr class="separator:a9586763e04eccc001fa17f80d0f1c685"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Separating Axis Theorem (SAT) Tests written in C99. </p>
<hr  />
 <h2><a class="anchor" id="autotoc_md32"></a>
Licensing information at end of header</h2>
<h2><a class="anchor" id="autotoc_md33"></a>
Features:</h2>
<ul>
<li>Written in C99</li>
<li>Single header library for easy build system integration</li>
<li>Tests overlaps for AABBs, polygons, and circles using SAT</li>
<li>Provides collision information including the normal and amount of overlap</li>
<li>Ray casts against line segments, polygons, and circles</li>
<li>Permissive license (MIT)</li>
</ul>
<h2><a class="anchor" id="autotoc_md34"></a>
Summary:</h2>
<p>The Separating Axis Theorem (SAT) roughly states that two convex shapes do not intersect if there is an axis separating them. In the case of simple shapes the theorem provides necessary and sufficient conditions. For example, in the case of convex polygons, it is sufficient to test the axises along the edge normals of both polygons.</p>
<p>SAT tests are reasonably efficient and are frequently used for static, narrow phase, collision detection in games.</p>
<p>This library provides SAT tests for polygons, AABBs (which are, of course, polygons), and circles. Manifold objects can be passed to test functions so that, in the case of a collision, they will contain the colliding edge normal, overlap (minimum translational distance or MTD), and a vector (minimum translation vector or MTV).</p>
<p>Rays (directed line segments) can be cast against line segments, polygons, and circles. Aside from reporting hits, the normal at and distance to the point of impact is also available.</p>
<p>IMPORTANT: Polygons in this library use counter-clockwise (CCW) winding. See the <code>ph_aabb_to_poly</code> for an example.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Usage:</h2>
<p>To use this library in your project, add the following</p>
<blockquote class="doxtable">
<p>&zwj;#define PICO_HIT_IMPLEMENTATION #include "pico_hit.h" </p>
</blockquote>
<p>to a source file (once), then simply include the header normally.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Dependencies:</h2>
<p>This library depends on "pico_math.h", which must be in the include path. You must also add</p>
<blockquote class="doxtable">
<p>&zwj;#define PICO_MATH_IMPLEMENTATION #include "pico_math.h" </p>
</blockquote>
<p>to the same or other source file (once). </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a46867f0870ad57fe9c2c0ae48e42428b" name="a46867f0870ad57fe9c2c0ae48e42428b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46867f0870ad57fe9c2c0ae48e42428b">&#9670;&#160;</a></span>PICO_HIT_MAX_POLY_VERTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICO_HIT_MAX_POLY_VERTS&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adba91cbb255f36b2a3fb0109f299cca4" name="adba91cbb255f36b2a3fb0109f299cca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba91cbb255f36b2a3fb0109f299cca4">&#9670;&#160;</a></span>ph_make_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structph__circle__t.html">ph_circle_t</a> ph_make_circle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpv2.html">pv2</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pico__math_8h.html#a5ce19b909a88aefe3e3a3beac779f98c">pfloat</a>&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Circle center </td></tr>
    <tr><td class="paramname">radius</td><td>Circle radius </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d7955222df8d81bce86ccbec7902047" name="a4d7955222df8d81bce86ccbec7902047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7955222df8d81bce86ccbec7902047">&#9670;&#160;</a></span>ph_make_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structph__poly__t.html">ph_poly_t</a> ph_make_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpv2.html">pv2</a>&#160;</td>
          <td class="paramname"><em>vertices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_count</td><td>The number of vertices of the polygon </td></tr>
    <tr><td class="paramname">vertices</td><td>The vertices of the polygon (must use CCW winding) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The polygon with the given vertices </dd></dl>

</div>
</div>
<a id="a138aae4d2dc47b11a23e0e64dea6e2f0" name="a138aae4d2dc47b11a23e0e64dea6e2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138aae4d2dc47b11a23e0e64dea6e2f0">&#9670;&#160;</a></span>ph_make_ray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structph__ray__t.html">ph_ray_t</a> ph_make_ray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpv2.html">pv2</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpv2.html">pv2</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pico__math_8h.html#a5ce19b909a88aefe3e3a3beac779f98c">pfloat</a>&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a ray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The origin of the array </td></tr>
    <tr><td class="paramname">dir</td><td>The direction of the ray </td></tr>
    <tr><td class="paramname">dist</td><td>The length of the ray </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a840c8e99fc78fe7723587566b70e8ec5" name="a840c8e99fc78fe7723587566b70e8ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840c8e99fc78fe7723587566b70e8ec5">&#9670;&#160;</a></span>ph_aabb_to_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structph__poly__t.html">ph_poly_t</a> ph_aabb_to_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpb2.html">pb2</a> *&#160;</td>
          <td class="paramname"><em>aabb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts and axis-aligned bounding box (AABB) to a polygon. </p>
<p>aabb The AABB </p><dl class="section return"><dt>Returns</dt><dd>the AABB as a polygon </dd></dl>

</div>
</div>
<a id="a391ac270ec1bcf4a1040b5efa117581f" name="a391ac270ec1bcf4a1040b5efa117581f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391ac270ec1bcf4a1040b5efa117581f">&#9670;&#160;</a></span>ph_sat_poly_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ph_sat_poly_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structph__manifold__t.html">ph_manifold_t</a> *&#160;</td>
          <td class="paramname"><em>manifold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests to see if one polygon overlaps with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly_a</td><td>The colliding polygon </td></tr>
    <tr><td class="paramname">poly_b</td><td>The target polygon </td></tr>
    <tr><td class="paramname">manifold</td><td>The collision manifold to populate (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygons overlap and false otherwise </dd></dl>

</div>
</div>
<a id="ac3c37f7de9b8744012085830dbd10942" name="ac3c37f7de9b8744012085830dbd10942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c37f7de9b8744012085830dbd10942">&#9670;&#160;</a></span>ph_sat_poly_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ph_sat_poly_circle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structph__manifold__t.html">ph_manifold_t</a> *&#160;</td>
          <td class="paramname"><em>manifold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests to see if a polygon overlaps a circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The colliding polygon </td></tr>
    <tr><td class="paramname">circle</td><td>The target circle </td></tr>
    <tr><td class="paramname">manifold</td><td>The collision manifold to populate (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon and circle overlap, and false otherwise </dd></dl>

</div>
</div>
<a id="acd7ad518b177cb49a6a7771e4dd2317c" name="acd7ad518b177cb49a6a7771e4dd2317c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7ad518b177cb49a6a7771e4dd2317c">&#9670;&#160;</a></span>ph_sat_circle_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ph_sat_circle_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structph__manifold__t.html">ph_manifold_t</a> *&#160;</td>
          <td class="paramname"><em>manifold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests to see if a circle overlaps a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circle</td><td>The colliding circle </td></tr>
    <tr><td class="paramname">poly</td><td>The target polygon </td></tr>
    <tr><td class="paramname">manifold</td><td>The collision manifold to populate (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the circle overlaps the polygon, and false otherwise </dd></dl>

</div>
</div>
<a id="aade0516489f38a2b5dda23d26e976bc8" name="aade0516489f38a2b5dda23d26e976bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade0516489f38a2b5dda23d26e976bc8">&#9670;&#160;</a></span>ph_sat_circle_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ph_sat_circle_circle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structph__manifold__t.html">ph_manifold_t</a> *&#160;</td>
          <td class="paramname"><em>manifold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests to see if two circles overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circle_a</td><td>The colliding circle </td></tr>
    <tr><td class="paramname">circle_b</td><td>The target circle </td></tr>
    <tr><td class="paramname">manifold</td><td>The collision manifold to populate (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the circle and the other circle, and false otherwise </dd></dl>

</div>
</div>
<a id="a98102c714c9d66eae29fd2ae7b7467c0" name="a98102c714c9d66eae29fd2ae7b7467c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98102c714c9d66eae29fd2ae7b7467c0">&#9670;&#160;</a></span>ph_ray_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ph_ray_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__ray__t.html">ph_ray_t</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpv2.html">pv2</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpv2.html">pv2</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structph__raycast__t.html">ph_raycast_t</a> *&#160;</td>
          <td class="paramname"><em>raycast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if ray intersects a (directed) line segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Ray to test </td></tr>
    <tr><td class="paramname">s1</td><td>First endpoint of segment </td></tr>
    <tr><td class="paramname">s2</td><td>Second endpoint of segment </td></tr>
    <tr><td class="paramname">raycast</td><td>Normal and distance of impact (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the ray collides with the line segment and false otherwise </dd></dl>

</div>
</div>
<a id="adf724b6bd2a2ec0bbd2e856891a677d8" name="adf724b6bd2a2ec0bbd2e856891a677d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf724b6bd2a2ec0bbd2e856891a677d8">&#9670;&#160;</a></span>ph_ray_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ph_ray_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__ray__t.html">ph_ray_t</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structph__raycast__t.html">ph_raycast_t</a> *&#160;</td>
          <td class="paramname"><em>raycast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if ray intersects a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Ray to test </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon </td></tr>
    <tr><td class="paramname">raycast</td><td>Normal and distance of impact (or NULL). May terminate early if NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the ray collides with the polygon and false otherwise </dd></dl>

</div>
</div>
<a id="a6ad5a532706b71964df83f760ba5e9a3" name="a6ad5a532706b71964df83f760ba5e9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad5a532706b71964df83f760ba5e9a3">&#9670;&#160;</a></span>ph_ray_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ph_ray_circle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__ray__t.html">ph_ray_t</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structph__raycast__t.html">ph_raycast_t</a> *&#160;</td>
          <td class="paramname"><em>raycast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if ray intersects a circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>Ray to test </td></tr>
    <tr><td class="paramname">circle</td><td>The circle </td></tr>
    <tr><td class="paramname">raycast</td><td>Normal and distance of impact (if not NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the ray collides with the circle and false otherwise </dd></dl>

</div>
</div>
<a id="aea25a1a059e25326b1cd55bde287ca1e" name="aea25a1a059e25326b1cd55bde287ca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea25a1a059e25326b1cd55bde287ca1e">&#9670;&#160;</a></span>ph_ray_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpv2.html">pv2</a> ph_ray_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__ray__t.html">ph_ray_t</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pico__math_8h.html#a5ce19b909a88aefe3e3a3beac779f98c">pfloat</a>&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the point along the ray at the specified distance from the origin. </p>

</div>
</div>
<a id="a094c30e037fa667889996c4c1e5b33ca" name="a094c30e037fa667889996c4c1e5b33ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094c30e037fa667889996c4c1e5b33ca">&#9670;&#160;</a></span>ph_transform_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structph__poly__t.html">ph_poly_t</a> ph_transform_poly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpt2.html">pt2</a> *&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a polygon using an affine transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new polygon </dd></dl>

</div>
</div>
<a id="a208e8092fcc819c636dbc776361891e5" name="a208e8092fcc819c636dbc776361891e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208e8092fcc819c636dbc776361891e5">&#9670;&#160;</a></span>ph_transform_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structph__circle__t.html">ph_circle_t</a> ph_transform_circle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpt2.html">pt2</a> *&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a circle using an affine transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform </td></tr>
    <tr><td class="paramname">poly</td><td>The circle to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new circle </dd></dl>

</div>
</div>
<a id="a180767bdb437174dc9d3bc23ac67005e" name="a180767bdb437174dc9d3bc23ac67005e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180767bdb437174dc9d3bc23ac67005e">&#9670;&#160;</a></span>ph_poly_to_aabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpb2.html">pb2</a> ph_poly_to_aabb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__poly__t.html">ph_poly_t</a> *&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounding box for the given polygon. </p>

</div>
</div>
<a id="a9586763e04eccc001fa17f80d0f1c685" name="a9586763e04eccc001fa17f80d0f1c685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9586763e04eccc001fa17f80d0f1c685">&#9670;&#160;</a></span>ph_circle_to_aabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpb2.html">pb2</a> ph_circle_to_aabb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structph__circle__t.html">ph_circle_t</a> *&#160;</td>
          <td class="paramname"><em>circle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounding box for the given circle. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
